#!/usr/bin/env python3

# MODULE:    v.out.keplergl
#
# AUTHOR(S): Vaclav Petras <wenzeslaus gmail com>
#
# PURPOSE:   Create Kepler.gl visualizations from vector maps
#
# COPYRIGHT: (C) 2020 Vaclav Petras, and by the GRASS Development Team
#
#            This program is free software under the GNU General Public
#            License (>=v2). Read the file COPYING that comes with GRASS
#            for details.

"""Kepler.gl visualization module for GRASS GIS

This executable script is a GRASS GIS module to run in a GRASS GIS session.
"""

#%module
#% description: Create Kepler.gl visualizations
#% keyword: vector
#% keyword: cartography
#% keyword: visualization
#% keyword: web
#%end
#%option G_OPT_V_INPUT
#%end
#%option G_OPT_F_OUTPUT
#%end
#%option G_OPT_DB_COLUMN
#% key: color_column
#% label: Column to be used for color
#%end
#%option G_OPT_DB_COLUMN
#% key: stroke_color_column
#% label: Column to be used for stroke color
#%end
#%option G_OPT_DB_COLUMN
#% key: height_column
#% label: Column to be used for height
#%end
#%option G_OPT_DB_COLUMNS
#% label: Columns to be displayed in tooltip
#% description: Defaults to all columns
#%end
#%option
#% key: title
#% label: Title of the resulting map
#% answer: Generated by v.out.keplergl
#%end
#%option
#% key: zoom
#% label: Zoom level of the web map
#% description: Center of the map is determined from the computational region
#% answer: 5
#%end
#%option
#% key: label
#% label: Label of the data (layer)
#% description: Defaults to map title (TODO) or name
#%end
#%option G_OPT_F_INTPUT
#% key: style
#% label: Style of the layer for Kepler.gl
#% description: visConfig element content as JSON, YAML or Python literal (.py)
#%end
#%rules
#% requires: color_column, style
#%end
#%rules
#% requires: height_column, style
#%end

import os
import sys
import json

import grass.script as gs

try:
    from grass.script import sql_type_is_float
except ImportError:
    _SQL_FLOAT_TYPES = [
        "REAL",
        "DOUBLE",
        "DOUBLE PRECISION",
        "FLOAT",
        "FLOATING POINT",
    ]

    def sql_type_is_float(sql_type):
        """Return True if SQL type is floating point

        Returns True for known floating point types, False otherwise.
        """
        return sql_type.upper() in _SQL_FLOAT_TYPES


def load_key_value_file(filename):
    """Load nested dict structure from a file.

    Supported formats are JSON, YAML, and Python literals.
    Formats are distinguised by extension.
    Extension for Python literals is `.py`, `.dict`, and `.pydict`.

    This function lazy imports all non-standard dependencies.
    """
    # We don't want to depend on the packages when we don't need them.
    # pylint: disable=import-outside-toplevel
    lower = filename.lower()
    if lower.endswith(".json"):
        with open(filename) as file:
            return json.loads(file.read())
    elif lower.endswith(".yaml") or lower.endswith(".yml"):
        import yaml

        with open(filename) as file:
            if hasattr(yaml, "full_load"):
                return yaml.full_load(file)
            return yaml.load(file)
    elif lower.endswith(".py") or lower.endswith(".dict") or lower.endswith(".pydict"):
        import ast

        with open(filename) as file:
            return ast.literal_eval(file.read())
    raise ValueError(f"Unknown file extension (file: {filename})")


def create_base_configuration():
    """Get basic structure for configuration"""
    return {
        "version": "v1",
        "config": {
            "visState": {
                "filters": [],
                "layers": [],
                "interactionConfig": {
                    "tooltip": {"fieldsToShow": {}, "enabled": True},
                    "brush": {"size": 0.5, "enabled": False},
                    "geocoder": {"enabled": False},
                    "coordinate": {"enabled": False},
                },
                "layerBlending": "normal",
                "splitMaps": [],
                "animationConfig": {"currentTime": None, "speed": 1},
            },
            "mapState": None,
            "mapStyle": {
                "styleType": "dark",
                "topLayerGroups": {},
                "visibleLayerGroups": {
                    "label": False,
                    "road": True,
                    "border": False,
                    "building": True,
                    "water": True,
                    "land": True,
                    "3d building": False,
                },
                "threeDBuildingColor": [
                    9.665468314072013,
                    17.18305478057247,
                    31.1442867897876,
                ],
                "mapStyles": {},
            },
        },
    }


def load_style_from_file(filename):
    """Load the style (visConfig) from a file

    Looks for visConfig element value in the full Map Config file,
    looks for the visConfig element at top level,
    or assumes the whole file content is visConfig content
    (in this order).

    Calls fatal when the file does not exist or its format was not recognized.

    See load_key_value_file() for the supported formats.
    """
    if not os.path.exists(filename) or not os.path.isfile(filename):
        gs.fatal(_("Style file <{filename}> does not exist").format(filename=filename))
    try:
        style = load_key_value_file(filename)
    except ValueError as error:
        gs.fatal(_("Format of style file not recognized: {error}").format(error=error))
    if "config" in style:
        return style["config"]["visState"]["layers"][0]["config"]["visConfig"]
    if "visConfig" in style:
        return style["visConfig"]
    return style


def add_layer(config, data_id, label, visual_channels, style_file):
    """Add layer to configuration

    Currently, only one layer is possible since id is hardcoded.
    """
    if style_file:
        style = load_style_from_file(style_file)
    else:
        style = {}

    layer = {
        "id": "m1vnv5v",
        "type": "geojson",
        "config": {
            "dataId": data_id,
            "label": label,
            "color": [136, 87, 44],
            "columns": {"geojson": "_geojson"},
            "isVisible": True,
            "visConfig": {},
            "hidden": False,
            "textLabel": [
                {
                    "field": None,
                    "color": [255, 255, 255],
                    "size": 18,
                    "offset": [0, 0],
                    "anchor": "start",
                    "alignment": "center",
                }
            ],
        },
        "visualChannels": visual_channels,
    }
    for key, value in style.items():
        # Assuming only one layer here.
        layer["config"]["visConfig"][key] = value

    config["config"]["visState"]["layers"].append(layer)


def create_visual_channels(color_column, stroke_color_column, height_column):
    """Get visual channels configuration for a layer.

    Parameters set to None are not included.
    """
    visual_channels = {
        "colorField": None,
        "colorScale": "quantize",
        "sizeField": None,
        "sizeScale": "linear",
        "strokeColorField": None,
        "strokeColorScale": "quantize",
        "heightField": None,
        "heightScale": "linear",
        "radiusField": None,
        "radiusScale": "linear",
    }
    if color_column:
        visual_channels["colorField"] = {
            "name": color_column.name,
            "type": color_column.kepler_type,
        }
        visual_channels["colorScale"] = color_column.kepler_scale
    if stroke_color_column:
        visual_channels["strokeColorField"] = {
            "name": stroke_color_column.name,
            "type": stroke_color_column.kepler_type,
        }
        visual_channels["strokeColorScale"] = stroke_color_column.kepler_scale
    if height_column:
        visual_channels["heightField"] = {
            "name": height_column.name,
            "type": height_column.kepler_type,
        }
        # TODO: More complicated system than one fixed property is needed
        # for height, radius and size. Maybe just size and color scale properties.
    return visual_channels


def add_map_state(config, zoom):
    """Add map state to the configuration.

    Center of the map is determined from the region, zoom from the parameter.
    """
    center = gs.parse_command("g.region", flags="cg")
    longitude = float(center["center_easting"])
    latitude = float(center["center_northing"])

    map_state = {
        "bearing": 0,
        "dragRotate": False,
        "latitude": latitude,
        "longitude": longitude,
        "pitch": 0,
        "zoom": int(zoom),
        "isSplit": False,
    }
    config["config"]["mapState"] = map_state


def write_html(geojson_file, data_id, output_html, config, title):
    """Write Kepler.gl HTML and update its content"""
    # Lazy load non-standard dependencies to play nicely in cases
    # when only interface description is requested and the module
    # actually does not run.
    try:
        # pylint: disable=import-outside-toplevel
        from keplergl import KeplerGl
        from in_place import InPlace
    except ImportError as error:
        gs.fatal(
            _("Missing mandatory keplergl or in_place dependencies: {error}").format(
                error=error
            )
        )

    # Useful to examine the resulting configuration
    # print("Using configuration (JSON syntax):")
    # print(json.dumps(config, indent=2))
    kepler = KeplerGl(config=config)
    kepler.add_data(data=open(geojson_file).read(), name=data_id)
    kepler.save_to_html(file_name=output_html)

    # Add map title and creator
    with InPlace(output_html) as file:
        for line in file:
            line = line.replace(
                "<title>Kepler.gl</title>",
                f"<title>{title} &ndash; GRASS GIS Kepler.gl</title>",
            )
            line = line.replace("Kepler.gl Jupyter", title)
            file.write(line)


class Column:
    """Holds metadata about a column"""

    def __init__(self, name, column_infos):
        """Takes name of the column and dict from grass.script.vector_columns()"""
        self._infos = column_infos
        self.name = name

    def __bool__(self):
        """Return True if the name was set.

        Returns false when the name is empty or None allowing user to
        not set the column in the module interface.
        """
        return bool(self.name)

    @property
    def sql_type(self):
        """SQL type as a string"""
        return self._infos[self.name]["type"]

    def is_float(self):
        """Return True if SQL type a float type in Python?"""
        return sql_type_is_float(self.sql_type)

    @property
    def kepler_type(self):
        """Kepler.gl type of the column

        Only real and integer supported/tested for now.
        """
        if self.is_float():
            return "real"
        return "integer"

    @property
    def kepler_scale(self):
        """Kepler.gl scale for the column

        quantile for float and quantize for anything else.
        """
        if self.is_float():
            return "quantile"
        return "quantize"


def check_columns(column_names, column_infos, vector_name, layer):
    """Fail with fatal when one of the columns does not exist

    *column_names* is a list. An empty string or None in the list is skipped.
    This allows user not to provide the name in the module interface.
    """
    for column in column_names:
        if column and column not in column_infos:
            gs.fatal(
                _(
                    "Column <{column}> does not exists"
                    " in vector map {vector_name} (layer {vector_layer})"
                ).format(column=column, vector_name=vector_name, vector_layer=layer)
            )


def main():
    """Processes command line and directs the creation of the visualization"""
    options, unused_flags = gs.parser()
    vector_input = options["input"]
    output_html = options["output"]
    title = options["title"]

    data_id = vector_input.replace("@", "__at__")

    # TODO: since we are specifying vector columns, we need to specify layer.
    layer = 1
    column_infos = gs.vector_columns(vector_input, layer)

    if options["columns"]:
        show_columns = options["columns"].split(",")
    else:
        # Not providing any columns makes Kepler to show all.
        show_columns = []

    check_columns(
        column_names=[
            options["color_column"],
            options["stroke_color_column"],
            options["height_column"],
        ]
        + show_columns,
        column_infos=column_infos,
        vector_name=vector_input,
        layer=layer,
    )

    if options["label"]:
        data_label = options["label"]
    else:
        # TODO: Use map title if present, and only then map name as a default/fallback.
        data_label = vector_input

    config = create_base_configuration()
    visual_channels = create_visual_channels(
        color_column=Column(options["color_column"], column_infos),
        stroke_color_column=Column(options["stroke_color_column"], column_infos),
        height_column=Column(options["height_column"], column_infos),
    )
    add_layer(
        config,
        data_id=data_id,
        label=data_label,
        visual_channels=visual_channels,
        style_file=options["style"],
    )

    # Maybe move to add_columns_to_show(config,... function.
    config["config"]["visState"]["interactionConfig"]["tooltip"]["fieldsToShow"][
        data_id
    ] = show_columns

    add_map_state(config, zoom=options["zoom"])

    # TODO: Isn't system tmp file more appropriate?
    # or file in the already existing session tmp dir in system
    # This file is not cleaned up by the module (but only with session cleanups).
    geojson_file = gs.tempfile(create=False)
    gs.run_command(
        "v.out.ogr",
        input=vector_input,
        output=geojson_file,
        format="GeoJSON",
        flags="s",
        quiet=True,
    )

    write_html(
        geojson_file=geojson_file,
        data_id=data_id,
        output_html=output_html,
        config=config,
        title=title,
    )

    return 0


if __name__ == "__main__":
    sys.exit(main())
